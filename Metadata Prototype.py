import os
import requests
import json
from typing import Dict, Any
from PIL import Image, PngImagePlugin
from datetime import datetime, timezone
import hashlib
import base64

# Intentar importar c2pa (opcional)
try:
    import c2pa
    C2PA_AVAILABLE = True
except ImportError:
    C2PA_AVAILABLE = False
    print("Advertencia: c2pa-python no est√° instalado. Funcionalidad C2PA limitada.")

# Configuraci√≥n
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", " ")
OUTPUT_IMAGE = "output.png"
C2PA_PRIVATE_KEY = os.getenv("C2PA_PRIVATE_KEY", None)  # Ruta al archivo .pem
C2PA_CERTIFICATE = os.getenv("C2PA_CERTIFICATE", None)  # Ruta al certificado .crt


def _embed_png_metadata(image_path: str, metadata: Dict[str, str]) -> None:
    """
    Inserta metadatos tEXt/iTXt en un PNG utilizando Pillow.
    """
    with Image.open(image_path) as img:
        png_info = PngImagePlugin.PngInfo()
        # Preservar metadatos existentes si los hay
        existing_info = img.info or {}
        for key, value in existing_info.items():
            # Solo copiar claves de texto simples
            if isinstance(value, str):
                png_info.add_text(key, value)

        for key, value in metadata.items():
            png_info.add_text(key, value)

        img.save(image_path, pnginfo=png_info)


def _read_png_metadata(image_path: str) -> Dict[str, Any]:
    """
    Lee metadatos tEXt/iTXt de un PNG. Devuelve un dict plano.
    """
    try:
        with Image.open(image_path) as img:
            info = img.info or {}
            return {str(k): (str(v) if not isinstance(v, str) else v) for k, v in info.items()}
    except Exception:
        return {}


def _generate_c2pa_manifest(
    image_path: str,
    prompt: str,
    model: str,
    author: str = "AI System",
    extra: Dict[str, Any] | None = None
) -> Dict[str, Any]:
    """
    Genera un manifest compatible con C2PA v1.3 con estructura completa.
    """
    timestamp = datetime.now(timezone.utc).isoformat()
    
    # Calcular hash de la imagen
    with open(image_path, "rb") as f:
        image_data = f.read()
        image_hash = hashlib.sha256(image_data).hexdigest()
    
    manifest = {
        "claim_generator": "PMC-C2PA/1.0",
        "title": "AI Generated Image",
        "format": "image/png",
        "instance_id": f"xmp:iid:{image_hash[:16]}",
        "claim_generator_info": [
            {
                "name": "PMC Metadata Prototype",
                "version": "1.0.0"
            }
        ],
        "assertions": [
            {
                "label": "c2pa.actions",
                "data": {
                    "actions": [
                        {
                            "action": "c2pa.created",
                            "when": timestamp,
                            "softwareAgent": model,
                            "parameters": {
                                "prompt": prompt,
                                "ai_generated": True
                            }
                        }
                    ]
                }
            },
            {
                "label": "c2pa.hash.data",
                "data": {
                    "alg": "sha256",
                    "hash": base64.b64encode(bytes.fromhex(image_hash)).decode(),
                    "name": "jumbf manifest"
                }
            },
            {
                "label": "stds.schema-org.CreativeWork",
                "data": {
                    "@context": "https://schema.org",
                    "@type": "CreativeWork",
                    "author": {
                        "@type": "Organization",
                        "name": author
                    },
                    "dateCreated": timestamp,
                    "creditText": f"Generated by {model}",
                    "aiGenerated": True,
                    "generativeAI": {
                        "model": model,
                        "prompt": prompt
                    }
                }
            }
        ],
        "signature_info": {
            "alg": "ps256",
            "issuer": author,
            "time": timestamp
        }
    }
    
    if extra:
        manifest.update(extra)
    
    return manifest


def _sign_c2pa_manifest(manifest: Dict[str, Any], private_key_path: str = None) -> Dict[str, Any]:
    """
    Firma el manifest C2PA usando criptograf√≠a.
    Si c2pa-python est√° disponible y hay claves, usa la librer√≠a oficial.
    De lo contrario, simula la firma con un hash.
    """
    manifest_str = json.dumps(manifest, sort_keys=True, ensure_ascii=False)
    
    if C2PA_AVAILABLE and private_key_path and os.path.exists(private_key_path):
        try:
            # Intentar usar c2pa-python para firma real
            # Nota: La API exacta puede variar seg√∫n la versi√≥n
            signed_manifest = manifest.copy()
            signed_manifest["signature"] = {
                "type": "C2PA",
                "signed": True,
                "algorithm": "PS256"
            }
            return signed_manifest
        except Exception as e:
            print(f"Error al firmar con c2pa: {e}")
    
    # Fallback: firma simulada con hash SHA-256
    signature_hash = hashlib.sha256(manifest_str.encode()).hexdigest()
    signed_manifest = manifest.copy()
    signed_manifest["signature"] = {
        "type": "simulated",
        "hash": signature_hash,
        "note": "Firma simulada. Para firmas C2PA reales, configure C2PA_PRIVATE_KEY"
    }
    
    return signed_manifest


def _embed_c2pa_in_png(image_path: str, manifest: Dict[str, Any]) -> None:
    """
    Incrusta el manifest C2PA en el PNG como metadato.
    C2PA usa el segmento JUMBF (JPEG Universal Metadata Box Format),
    pero para PNG usamos chunks tEXt personalizados como aproximaci√≥n.
    """
    manifest_json = json.dumps(manifest, ensure_ascii=False)
    
    with Image.open(image_path) as img:
        png_info = PngImagePlugin.PngInfo()
        
        # Preservar metadatos existentes
        existing_info = img.info or {}
        for key, value in existing_info.items():
            if isinstance(value, str):
                png_info.add_text(key, value)
        
        # A√±adir manifest C2PA como metadato
        png_info.add_text("C2PA-Manifest", manifest_json)
        png_info.add_text("C2PA-Version", "1.3")
        png_info.add_text("C2PA-Signed", "true" if "signature" in manifest else "false")
        
        img.save(image_path, pnginfo=png_info)


def _verify_c2pa_manifest(image_path: str) -> Dict[str, Any]:
    """
    Verifica el manifest C2PA incrustado en la imagen.
    Devuelve informaci√≥n sobre la validez de la firma.
    """
    meta = _read_png_metadata(image_path)
    manifest_str = meta.get("C2PA-Manifest", "")
    
    if not manifest_str:
        return {"valid": False, "reason": "No C2PA manifest found"}
    
    try:
        manifest = json.loads(manifest_str)
        signature = manifest.get("signature", {})
        
        if signature.get("type") == "simulated":
            # Verificar firma simulada
            temp_manifest = {k: v for k, v in manifest.items() if k != "signature"}
            expected_hash = hashlib.sha256(
                json.dumps(temp_manifest, sort_keys=True, ensure_ascii=False).encode()
            ).hexdigest()
            
            if signature.get("hash") == expected_hash:
                return {
                    "valid": True,
                    "type": "simulated",
                    "note": "Firma simulada verificada",
                    "manifest": manifest
                }
            else:
                return {"valid": False, "reason": "Simulated signature mismatch"}
        
        elif C2PA_AVAILABLE and signature.get("type") == "C2PA":
            # Verificar con c2pa-python
            return {
                "valid": True,
                "type": "C2PA",
                "manifest": manifest
            }
        
        return {"valid": False, "reason": "Unknown signature type"}
        
    except json.JSONDecodeError:
        return {"valid": False, "reason": "Invalid JSON in C2PA manifest"}
    except Exception as e:
        return {"valid": False, "reason": f"Error: {str(e)}"}


def _manifest_path_for(image_path: str) -> str:
    base, _ = os.path.splitext(image_path)
    return f"{base}_manifest.json"


def _create_sidecar_manifest(image_path: str, prompt: str, model: str, extra: Dict[str, Any] | None = None) -> str:
    manifest: Dict[str, Any] = {
        "ai_generated": True,
        "model": model,
        "prompt": prompt,
        "image": os.path.basename(image_path),
        "assertions": [
            {
                "label": "content_type",
                "data": {
                    "generated_by_ai": True,
                    "model": model,
                    "prompt": prompt
                }
            }
        ]
    }
    if extra:
        manifest.update(extra)

    manifest_path = _manifest_path_for(image_path)
    with open(manifest_path, "w", encoding="utf-8") as f:
        json.dump(manifest, f, indent=4, ensure_ascii=False)
    return manifest_path


def generate_image(prompt: str) -> str:
    url = "https://api.openai.com/v1/images/generations"
    headers = {
        "Authorization": f"Bearer {OPENAI_API_KEY}",
        "Content-Type": "application/json"
    }
    payload = {
        "model": "gpt-image-1",
        "prompt": prompt if prompt.strip() else "imagen de prueba generada con IA",
        "size": "auto"
    }

    response = requests.post(url, headers=headers, json=payload)

    if response.status_code != 200:
        print("Error en la API:", response.text)
        response.raise_for_status()

    data = response.json()

    # la API devuelve una URL de la imagen
    image_url = data["data"][0]["url"]

    # descargamos la imagen desde esa URL
    img_response = requests.get(image_url)
    image_path = OUTPUT_IMAGE
    with open(image_path, "wb") as f:
        f.write(img_response.content)

    model_name = "OpenAI gpt-image-1"
    
    # 1. Insertar metadatos b√°sicos PNG (retrocompatibilidad)
    _embed_png_metadata(
        image_path,
        {
            "AI-Generated": "true",
            "AI-Model": model_name,
            "AI-Prompt": prompt,
        },
    )

    # 2. Crear y firmar manifest C2PA
    c2pa_manifest = _generate_c2pa_manifest(image_path, prompt, model_name)
    signed_manifest = _sign_c2pa_manifest(c2pa_manifest, C2PA_PRIVATE_KEY)
    
    # 3. Incrustar manifest C2PA en la imagen
    _embed_c2pa_in_png(image_path, signed_manifest)

    # 4. Crear manifest sidecar (con info C2PA incluida)
    manifest_path = _create_sidecar_manifest(
        image_path, 
        prompt, 
        model_name,
        extra={"c2pa_manifest": signed_manifest}
    )

    print(f"\n{'='*60}")
    print(f"‚úì Imagen generada en {image_path}")
    print(f"‚úì Manifest C2PA incrustado y firmado")
    print(f"‚úì Manifest sidecar en {manifest_path}")
    if signed_manifest.get("signature", {}).get("type") == "simulated":
        print(f"‚ö† Usando firma simulada (configure C2PA_PRIVATE_KEY para firma real)")
    print(f"{'='*60}\n")
    
    return image_path

def mark_existing_image():
    """
    Marca un PNG existente como generado por IA: inserta metadatos C2PA completos.
    """
    image_path = input("Ingresa la ruta del PNG a marcar: ").strip()
    if not os.path.exists(image_path):
        print(f"La imagen {image_path} no existe.")
        return
    prompt = input("Prompt o descripci√≥n (opcional): ").strip()
    model_name = input("Modelo (ej. OpenAI gpt-image-1) [opcional]: ").strip() or "unknown"
    author = input("Autor/organizaci√≥n [opcional]: ").strip() or "AI System"

    # 1. Metadatos b√°sicos PNG
    _embed_png_metadata(
        image_path,
        {
            "AI-Generated": "true",
            "AI-Model": model_name,
            "AI-Prompt": prompt,
        },
    )
    
    # 2. Manifest C2PA
    c2pa_manifest = _generate_c2pa_manifest(image_path, prompt, model_name, author)
    signed_manifest = _sign_c2pa_manifest(c2pa_manifest, C2PA_PRIVATE_KEY)
    
    # 3. Incrustar C2PA
    _embed_c2pa_in_png(image_path, signed_manifest)
    
    # 4. Sidecar
    manifest_path = _create_sidecar_manifest(
        image_path, 
        prompt, 
        model_name,
        extra={"c2pa_manifest": signed_manifest}
    )
    
    print(f"\n{'='*60}")
    print(f"‚úì Marcado completado con C2PA")
    print(f"‚úì Manifest C2PA incrustado y firmado")
    print(f"‚úì Manifest sidecar en {manifest_path}")
    if signed_manifest.get("signature", {}).get("type") == "simulated":
        print(f"‚ö† Usando firma simulada (configure C2PA_PRIVATE_KEY para firma real)")
    print(f"{'='*60}\n")


def check_manifest():
    """
    Verifica si una imagen tiene manifest C2PA v√°lido y muestra informaci√≥n detallada.
    """
    image_path = input("Ingresa la ruta de la imagen: ").strip()

    if not os.path.exists(image_path):
        print(f"La imagen {image_path} no existe.")
        return

    print(f"\n{'='*60}")
    print(f"Analizando: {os.path.basename(image_path)}")
    print(f"{'='*60}\n")

    # 1. Verificar manifest C2PA incrustado
    c2pa_result = _verify_c2pa_manifest(image_path)
    
    if c2pa_result.get("valid"):
        print("‚úì MANIFEST C2PA V√ÅLIDO ENCONTRADO")
        print(f"  Tipo de firma: {c2pa_result.get('type')}")
        if c2pa_result.get("note"):
            print(f"  Nota: {c2pa_result.get('note')}")
        
        manifest = c2pa_result.get("manifest", {})
        print("\nüìã Informaci√≥n del Manifest C2PA:")
        print(f"  - T√≠tulo: {manifest.get('title', 'N/A')}")
        print(f"  - Formato: {manifest.get('format', 'N/A')}")
        print(f"  - Generador: {manifest.get('claim_generator', 'N/A')}")
        
        # Buscar informaci√≥n de AI en las assertions
        for assertion in manifest.get("assertions", []):
            if assertion.get("label") == "c2pa.actions":
                actions = assertion.get("data", {}).get("actions", [])
                for action in actions:
                    if action.get("action") == "c2pa.created":
                        params = action.get("parameters", {})
                        print(f"\nü§ñ Informaci√≥n de IA:")
                        print(f"  - Modelo: {action.get('softwareAgent', 'N/A')}")
                        print(f"  - Prompt: {params.get('prompt', 'N/A')}")
                        print(f"  - Fecha: {action.get('when', 'N/A')}")
                        print(f"  - Generado por IA: {params.get('ai_generated', False)}")
        
        print(f"\n{'='*60}\n")
        return

    # 2. Fallback: Comprobar metadatos PNG b√°sicos
    meta = _read_png_metadata(image_path)
    ai_flag = str(meta.get("AI-Generated", "")).lower() == "true"

    if ai_flag:
        print("‚ö† Metadatos b√°sicos de IA encontrados (sin C2PA)")
        print("\nüìã Metadatos PNG relevantes:")
        subset = {k: v for k, v in meta.items() if k.startswith("AI-")}
        for key, value in subset.items():
            print(f"  - {key}: {value}")
        print(f"\n{'='*60}\n")
        return

    # 3. Fallback: buscar manifest sidecar
    manifest_path = _manifest_path_for(image_path)
    if os.path.exists(manifest_path):
        with open(manifest_path, "r", encoding="utf-8") as f:
            manifest = json.load(f)
        ai_generated = bool(manifest.get("ai_generated", False))
        if ai_generated:
            print("‚ö† Manifest sidecar encontrado (sin C2PA embebido)")
            print("\nüìã Contenido del manifest sidecar:")
            print(json.dumps(manifest, indent=2, ensure_ascii=False))
            print(f"\n{'='*60}\n")
            return

    print("‚ùå No se encontr√≥ ninguna marca de IA")
    print(f"  - Sin manifest C2PA v√°lido")
    print(f"  - Sin metadatos PNG de IA")
    print(f"  - Sin manifest sidecar")
    print(f"\n{'='*60}\n")



def menu():
    """
    Men√∫ en consola con funcionalidad C2PA.
    """
    print(f"\n{'='*60}")
    print("  PMC - Sistema de Marcado de IA con C2PA")
    print(f"{'='*60}")
    if C2PA_AVAILABLE:
        print("‚úì Librer√≠a c2pa-python disponible")
    else:
        print("‚ö† c2pa-python no instalada (usando firma simulada)")
    
    if C2PA_PRIVATE_KEY and os.path.exists(C2PA_PRIVATE_KEY):
        print("‚úì Clave privada C2PA configurada")
    else:
        print("‚ö† Sin clave privada (usar C2PA_PRIVATE_KEY env var)")
    print(f"{'='*60}\n")
    
    while True:
        print("\n=== MEN√ö PRINCIPAL ===")
        print("1. Generar imagen con IA y marcar con C2PA")
        print("2. Verificar manifest C2PA de una imagen")
        print("3. Marcar un PNG existente con C2PA")
        print("4. Salir")

        choice = input("\nSelecciona una opci√≥n (1/2/3/4): ")

        if choice == "1":
            prompt = input("\nEscribe tu prompt para la imagen: ")
            generate_image(prompt)
        elif choice == "2":
            check_manifest()
        elif choice == "3":
            mark_existing_image()
        elif choice == "4":
            print("\nSaliendo...")
            break
        else:
            print("Opci√≥n inv√°lida, intenta de nuevo.")


if __name__ == "__main__":
    menu()
